<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	
	<link rel="stylesheet" href="styles.css">

	<script type="importmap">
	  {
		"imports": {
		  "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
		  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/"
		}
	  }
	</script>
</head>

<body>

	<h1 class="white">Project goals</h1>
	<h3 class="white">Normal texture — vs — Equirectangular texture — vs — Equirectangular texture + shader fix</h3>
	
	<script type="module">

		import * as THREE from "three";
		import { OrbitControls } from "three/addons/controls/OrbitControls.js";
		import { mergeVertices } from 'three/addons/utils/BufferGeometryUtils.js';
		import { equimaterial, equitexture, noise } from "../src/texture-generator.js";


		
		
		// setting up the scene
		
		var scene = new THREE.Scene();
			scene.background = new THREE.Color( 'black' );
				
		var camera = new THREE.PerspectiveCamera( 5, innerWidth/innerHeight );
			camera.position.set( 0, 0, 100 );
			camera.lookAt( scene.position );

		var renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( innerWidth, innerHeight );
			renderer.setAnimationLoop( animationLoop );
			document.body.appendChild( renderer.domElement );
					
		window.addEventListener( "resize", (event) => {
			camera.aspect = innerWidth/innerHeight;
			camera.updateProjectionMatrix( );
			renderer.setSize( innerWidth, innerHeight );
		});

		var hiddenCamera = camera.clone();
			hiddenCamera.position.set(0,0,1);
		
		var controls = new OrbitControls( hiddenCamera, renderer.domElement );
			controls.enableDamping = true;
			controls.autoRotate = !true;
			controls.autoRotateSpeed = 0.5;

		var light = new THREE.PointLight( 'white', 4 );
			light.position.set( 0, 0, 100 );
			light.decay = 0;
			scene.add( light );
	

		// =================================
		//
		// LEFT BALL - ORIGINAL TEXTURE
		//
		// =================================

		var canvas = document.createElement( 'canvas' );
			canvas.width = 1024;
			canvas.height = 512;

		var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 1024, 512 );
			context.fillStyle = 'black';
			
		context.filter = "blur(6px)";
		for( var y=-1; y<256/32+1; y++)
		for( var x=-1; x<1024/32+1; x++)
		if( (x+y)%2 )
		{
			context.beginPath( );
			context.arc( 32*x, 32*y, 20, 0, 2*Math.PI );
			context.fill( );
		}
		context.filter = "none";
		for( var y=-1; y<256/32+1; y++)
		for( var x=-1; x<1024/32+1; x++)
		if( (x+y)%2 )
		{
			context.beginPath( );
			context.arc( 32*x, 32*y, 16, 0, 2*Math.PI );
			context.fill( );
		}

		context.fillStyle = 'white';
		context.fillRect( 0, 256, 1024, 256 );
		
		context.fillStyle = 'black';
		for( var x=-32; x<1024+32; x+=32)
			context.fillRect( x-3, 256, 7, 512 );

//		context.fillStyle = 'dimgray';
		context.fillRect( 0, 256-8, 1024, 16 );

		var leftBall = new THREE.Mesh(
				new THREE.SphereGeometry( 1, 16, 8 ),
//				new THREE.DodecahedronGeometry( 1 ),
				new THREE.MeshLambertMaterial( {
						map: new THREE.CanvasTexture( canvas )
					} )
		);

		var leftBall2 = new THREE.Mesh(
				new THREE.SphereGeometry( 1, 60, 30 ),
				new THREE.MeshLambertMaterial( {
						map: new THREE.CanvasTexture( canvas )
					} )
		);

		var leftPanel = new THREE.Mesh(
				new THREE.PlaneGeometry( 2.8, 1.4 ),
				leftBall.material
		);

		leftBall.position.set( -3, 2, 0 );
		leftBall2.position.set( -3, -2, 0 );
		leftPanel.position.set( -3, 0, 0 );
		
		scene.add( leftBall, leftBall2, leftPanel );


		// =================================
		//
		// MIDDLE BALL - EQUIRECTANGULAR TEXTURE
		//
		// =================================

		var vec = new THREE.Vector3();

		var dotPositions = new THREE.IcosahedronGeometry(1,3).getAttribute( 'position' );
		var dotPoints = [];
		for( var i=0; i<dotPositions.count; i++ )
			dotPoints.push( new THREE.Vector3().fromBufferAttribute( dotPositions, i ) );
			
		function pattern( x, y, z, color, {}, u, v, px, py )
		{
			vec.set( z, y, x );
			
			var dist = 1e10;
			for( var point of dotPoints )
				dist = Math.min( dist, vec.distanceTo(point) );
				
			var k = 1-0.005/dist**2.1;

	
			if( py>256-8 && py<256+8 )
				color.set( 0, 0, 0 );
			else
			if( v<0.5 )
				color.set( k, k, k );
			else
			{
				//if( Math.abs(px-Math.round(px/32)*32)<4 )
				k = 1.3-(Math.sin(16*Math.PI*z));
				color.set( k, k, k );
			}
		}
		
		var midBall = new THREE.Mesh(
				new THREE.SphereGeometry( 1, 16, 8 ),
//				new THREE.DodecahedronGeometry( 1 ),
				new THREE.MeshLambertMaterial( {map: equitexture(pattern,1024)} )
		);

		var midBall2 = new THREE.Mesh(
				new THREE.SphereGeometry( 1, 60, 30 ),
				midBall.material
		);

		var midPanel = new THREE.Mesh(
				new THREE.PlaneGeometry( 2.8, 1.4 ),
				midBall.material
		);
		
		midBall.position.set( 0, 2, 0 );
		midBall2.position.set( 0, -2, 0 );
		
		scene.add( midBall, midBall2, midPanel );
		



		// =================================
		//
		// RIGHT BALL - EQUIRECTANGULAR TEXTURE + SHADER FIX
		//
		// =================================
		
		var rightBall = new THREE.Mesh(
				new THREE.SphereGeometry( 1, 16, 8 ),
//				new THREE.DodecahedronGeometry( 1 ),
				equimaterial( new THREE.MeshLambertMaterial( {map: midBall.material.map} ) )
		);

		var rightBall2 = new THREE.Mesh(
				new THREE.SphereGeometry( 1, 60, 30 ),
				rightBall.material
		);

		var rightPanel = new THREE.Mesh(
				new THREE.PlaneGeometry( 2.8, 1.4 ),
				new THREE.MeshLambertMaterial( {map: rightBall.material.map} )
		);
		
		rightBall.position.set( 3, 2, 0 );
		rightBall2.position.set( 3, -2, 0 );
		rightPanel.position.set( 3, 0, 0 );
		
		scene.add( rightBall, rightBall2, rightPanel );
		
		
		function animationLoop( t )
		{
			controls.update( );
			
			for( var ball of [leftBall, leftBall2, midBall, midBall2, rightBall, rightBall2 /*rightBall*/])
			{
				ball.scale.setScalar( 1/controls.getDistance() );
				ball.quaternion.copy( hiddenCamera.quaternion ).conjugate();
			}

			renderer.render( scene, camera );
		}
				
	</script>
</body>
</html>